## 二叉树的递归遍历

###### 递归遍历的三个要素：

1.  **确定递归函数的参数和返回值**：确定哪些参数是递归过程中需要处理的，那么就在递归函数中加上这个参数，并且还要明确每次递归的返回值是什么来确定递归函数的返回类型
2.  **确定终止条件**：确定递归进行到什么条件时应该退出，不再向下递归
3.  **确定单层递归的逻辑**：确定每一层递归需要处理的信息。在这里会重复调用自己来实现递归。

###### 以前序遍历为例：

 1. **确定递归的参数和返回值**：由于需要对树进行处理，获取树节点中的值，故需要将树的根节点作为参数传入。而节点的值打印出来即可，故不需要返回值。

    ```python
    def traversal(root: TreeNode):
    ```

 2. **确定终止条件**：在递归过程中，遍历到空节点时，没有节点值可以获得，递归就应该结束，直接return

    ```python
    if root == None:
    	return
    ```

 3.  **确定单层递归逻辑**：前序遍历的顺序是**根左右**，所以单层递归逻辑应该先取根节点的值，再递归左子树，最后递归右子树。

    ```python
    print(root.val)
    traversal(root.left)
    traversal(root.right)
    ```

###### 前中后序遍历的参考答案：

```python
# 前序遍历-递归-LC144_二叉树的前序遍历
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 保存结果
        result = []
        
        def traversal(root: TreeNode):
            if root == None:
                return
            result.append(root.val) # 前序
            traversal(root.left)    # 左
            traversal(root.right)   # 右

        traversal(root)
        return result

# 中序遍历-递归-LC94_二叉树的中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            result.append(root.val) # 中序
            traversal(root.right)   # 右

        traversal(root)
        return result

# 后序遍历-递归-LC145_二叉树的后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            traversal(root.right)   # 右
            result.append(root.val) # 后序

        traversal(root)
        return result
```





