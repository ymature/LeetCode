## 二叉树的迭代遍历

###### 理由：

​	由于递归实现的二叉树遍历借用了系统栈，因此，我们可以使用栈结构来迭代实现二叉树上的遍历。

##### 统一的迭代写法：

​		**我们将访问的节点（遍历节点）放入栈中，把要处理的节点（取值的节点）也放入栈中但是要做标记。**

​		如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。

###### 前序遍历：根左右

​	由于输出顺序是**根左右**，因此，节点的入栈顺序为：**右左根**。这样出栈时的顺序就是**根左右**了。

##### 参考答案：

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st= []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None: # 不是要处理的节点
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
                st.append(node) #根
                st.append(None)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```

###### 中序遍历：左根右

​	由于输出顺序是**左根右**，因此，节点的入栈顺序为：**右根左**。这样出栈时的顺序就是**左根右**了。

##### 参看答案：

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #添加右节点（空节点不入栈）
                    st.append(node.right)
                
                st.append(node) #添加根节点
                st.append(None) #根节点访问过，但是还没有处理，加入空节点做为标记。
                
                if node.left: #添加左节点（空节点不入栈）
                    st.append(node.left)
            else: #只有遇到空节点的时候，才将下一个节点放进结果集
                node = st.pop() #重新取出栈中元素
                result.append(node.val) #加入到结果集
        return result
```

###### 后序遍历：左右根

​	由于输出顺序是**左右根**，因此，节点的入栈顺序为：**根右左**。这样出栈时的顺序就是**左右根**了。

##### 参考答案:

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #根
                st.append(None)
                
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```

