## 76. 最小覆盖子串

#### 题目描述

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 "" 。

 

**注意**：

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

```python
示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"
示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

- `1 <= s.length, t.length <= 105`
- `s` 和 `t` 由英文字母组成

##### 思路：（滑动窗口）

考虑一下三件事：

窗口内是什么： **可行**窗口（满足题意的一个窗口）中是包含`t`的子串。

窗口的右边界如何移动， 影响？：窗口不是可行窗口时，影响：添加了右边界字符，其余字符不受影响。

窗口的左边界如何移动、影响？：窗口是可行窗口时，影响：移除了左边界字符，其余字符不受影响。



以哈希表 `cnt` 记录目标字符串` t` 中**待匹配**的各字符的数目，并在 `s` 中维护一个变长的滑动窗口，期望使得窗口中的字符能够覆盖 `t`。需要注意的是，`cnt[ch]` 可以为**负值**，且**负值**表示当前窗口中的字符 ch 过多（多于目标字符 `t`）。

具体地，设定一个**非负**变量 `need` 表示在考虑了窗口中的全部元素后还需要匹配的总字符数目：

1. 当窗口中新加入一位字符 `ch` （窗口右边界向前移一位）时：


- 若 `cnt[ch]`>0，说明 `ch` 未加入窗口前我们对于字符 `ch` 还有需求，此时新加入的 `ch` 能够使得 `need`-1；


- 若 `cnt[ch]`≤0，说明 `ch` 未加入窗口前我们对于字符 `ch` 已无需求，此时新加入的 `ch` 不改变 `need`。
- 由于加入了一个`ch`字符，则`cnt[ch]`自减1，表示目标字符串`t`中的`ch`字符**待匹配**数目减少。

2. 当窗口中滑出一位字符 `ch`(窗口左边界向前移一位) 时：

- 若 `cnt[ch]`>0，说明 `ch` 未滑出窗口前我们对于字符 `ch` 仍然还有需求（滑出去需求更大了），此时滑出去的 `ch`能够使得`need+1`；
- 若 `cnt[ch]`=0，说明 `ch` 未滑出窗口前我们对于字符 `ch` 刚好无需求（滑出去后会对字符 `ch` 有需求了），此时滑出去的 `ch` 能够使得 `need+1`；
- 若 `cnt[ch]`<0，说明 `ch` 未滑出窗口前我们对于字符 `ch` 已无需求（过剩），此时滑出去的 `ch` 不改变 `need`。
- 由于滑出一个`ch`字符，则`cnt[ch]`自增1，表示目标字符串`t`中的`ch`字符**待匹配**数目增加

3. 当` need`=0 时，说明找到了一个满足题意的窗口（可行窗口），使得窗口中的字符能够覆盖 `t`。在记录下答案的同时，我们还需要尝试收缩窗口左边界（参照上一步）。





##### 参考答案

```python
def minWindow(self, s: str, t: str) -> str:
        if len(t) > len(s):
            return ""
        cnt = collections.Counter(t)  # 哈希表：记录待匹配的各个元素的数目
        need = len(t)  # 记录待匹配的字符总数【need=0表示匹配到了，即得到了可行窗口】
        left = right = 0 
        num = len(s) + 1  # 子串长度
        while right < len(s):
            # 窗口不是可行窗口时，窗口右边界向前移一位
            if cnt[s[right]] == None:  # 字符不是**t**中字符，则right向前移一位
                right += 1
                continue
            elif cnt[s[right]] > 0:  # 对当前字符还有需求
                need -= 1  # 加入s[right]字符后，待匹配总字符数减一
            cnt[s[right]] -= 1
            right += 1
            # 得到可行窗口时，窗口左边界向前移一位
            while need == 0:
                if num > right - left:
                    num = min(num, right - left)
                    begin = left
                if cnt[s[left]] >= 0:
                    need += 1
                cnt[s[left]] += 1
                left += 1
        return s[begin:num + begin] if num < len(s) + 1 else ""
```

